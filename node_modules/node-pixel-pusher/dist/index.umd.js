(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('dgram'), require('events')) :
    typeof define === 'function' && define.amd ? define(['exports', 'dgram', 'events'], factory) :
    (factory((global.pixelPusher = {}),global.dgram,global.events));
}(this, (function (exports,dgram,events) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var SEQUENCE_DENOTATION_LENGTH = 4;
    var STRIP_DENOTATION_LENGTH = 1;
    var NS_PER_SEC = 1e9;
    var MS_PER_NS = 1e-6;
    var Device = /** @class */ (function () {
        function Device(deviceData) {
            this.packetIndex = 0;
            this.packetSequenceNumber = 1;
            this.packetsPerRefresh = 1;
            this.minimumUpdatePeriod = 0;
            this.stripDataSize = 0;
            this.renderfn = function () { };
            this.shouldRender = false;
            this.deviceData = deviceData;
            this.packetBuffer = [];
            this.stripPacketData = [];
            this.stripDataSize = this.deviceData.pixelsPerStrip * 3;
            this.packetsPerRefresh = Math.ceil(this.deviceData.numberStrips / this.deviceData.stripsPerPkt);
            for (var p = 0; p < this.packetsPerRefresh; p++) {
                var stripOffset = this.deviceData.stripsPerPkt * p;
                var stripCount = Math.min(this.deviceData.stripsPerPkt, this.deviceData.numberStrips - stripOffset);
                var packetSize = SEQUENCE_DENOTATION_LENGTH + stripCount * (STRIP_DENOTATION_LENGTH + this.stripDataSize);
                var packet = (this.packetBuffer[p] = Buffer.alloc(packetSize));
                packet.fill(0x00);
                var pos = 4;
                var slen = stripOffset + stripCount;
                for (var s = stripOffset; s < slen; s++) {
                    packet.writeUInt8(s, pos);
                    // increment after writing UInt8
                    pos += 1;
                    this.stripPacketData.push({
                        packetIndex: p,
                        dataOffset: pos,
                        rgbaOffset: s * this.deviceData.pixelsPerStrip * 4
                    });
                    // increment to skip strip data
                    pos += this.stripDataSize;
                }
            }
            this.fullRefreshTick = this.fullRefreshTick.bind(this);
        }
        Device.prototype.setRGBABuffer = function (data) {
            if (data.length !== this.deviceData.numberStrips * this.deviceData.pixelsPerStrip * 4) {
                console.log('Invalid buffer size');
                return;
            }
            for (var y = 0; y < this.deviceData.numberStrips; y++) {
                var meta = this.stripPacketData[y];
                var target = this.packetBuffer[meta.packetIndex];
                for (var i = 0, j = 0; i < this.stripDataSize; i += 3, j += 4) {
                    target[meta.dataOffset + i] = data[meta.rgbaOffset + j];
                    target[meta.dataOffset + i + 1] = data[meta.rgbaOffset + j + 1];
                    target[meta.dataOffset + i + 2] = data[meta.rgbaOffset + j + 2];
                }
            }
        };
        Device.prototype.sendPacket = function (packet, deviceData) { };
        Device.prototype.fullRefreshTick = function () {
            var tickStartTime = process.hrtime();
            var sendPacket = true;
            if (!this.shouldRender) {
                // Stop render loop
                return;
            }
            if (this.packetIndex === 0) {
                // Request render data
                if (this.renderfn() === false) {
                    sendPacket = false;
                }
            }
            if (sendPacket) {
                var packet = this.packetBuffer[this.packetIndex];
                packet.writeUInt32LE(this.packetSequenceNumber++, 0);
                this.sendPacket(packet, this.deviceData);
                this.packetIndex = (this.packetIndex + 1) % this.packetsPerRefresh;
            }
            var tickHRTime = process.hrtime(tickStartTime);
            var tickMS = (tickHRTime[0] * NS_PER_SEC + tickHRTime[1]) * MS_PER_NS;
            setTimeout(this.fullRefreshTick, Math.max(
            // Don't go below update limit
            this.minimumUpdatePeriod, 
            // Skip to next frame render if we're not sending packets
            (sendPacket
                ? this.deviceData.updatePeriod
                : this.deviceData.updatePeriod * this.packetsPerRefresh) -
                // Remove time used by render/packet sending
                tickMS));
        };
        Device.prototype.setMaxFPS = function (maxFps) {
            this.minimumUpdatePeriod = 1000 / maxFps / this.packetsPerRefresh;
        };
        Device.prototype.startRendering = function (renderfn, maxFps) {
            var shouldStartRender = !this.shouldRender;
            if (maxFps) {
                this.setMaxFPS(maxFps);
            }
            this.renderfn = renderfn;
            if (shouldStartRender) {
                this.shouldRender = true;
                this.fullRefreshTick();
            }
        };
        Device.prototype.stopRendering = function () {
            this.shouldRender = false;
        };
        return Device;
    }());

    var LISTENER_SOCKET_PORT = 7331;
    var Service = /** @class */ (function (_super) {
        __extends(Service, _super);
        function Service() {
            var _this = _super.call(this) || this;
            _this.devices = {};
            _this.socket = dgram.createSocket('udp4');
            _this.socket.on('message', _this.onMessage.bind(_this));
            _this.socket.on('listening', function () {
                var address = _this.socket.address();
                console.log('Socket listening for PixelPusher on udp://*:' + address.port);
            });
            _this.socket.on('error', function (err) {
                console.log('Error opening socket to detect PixelPusher', err);
            });
            _this.socket.bind(LISTENER_SOCKET_PORT);
            return _this;
        }
        Service.prototype.close = function () {
            this.socket.close();
        };
        Service.prototype.onMessage = function (msg, rinfo) {
            var _this = this;
            if (msg.length < 48) {
                return;
            }
            var mac = msg
                .slice(0, 6)
                .toString('hex')
                .match(/.{2}/g)
                .join(':');
            if (!mac) {
                return;
            }
            var controller = this.devices[mac];
            if (controller && controller.deviceData.deviceType === 2) {
                // Already received message from this device
                var cycleTime = msg.readUInt32LE(28) / 1000;
                var delta = msg.readUInt32LE(36);
                if (delta > 5) {
                    cycleTime += 5;
                }
                else if (delta === 0 && cycleTime > 1) {
                    cycleTime -= 1;
                }
                controller.deviceData.updatePeriod = cycleTime;
                controller.deviceData.powerTotal = msg.readUInt32LE(32);
                controller.deviceData.deltaSequence = delta;
                return;
            }
            var ipAddress = msg
                .slice(6, 10)
                .toString('hex')
                .match(/.{2}/g)
                .map(function (x) {
                return parseInt(x, 16);
            })
                .join('.');
            if (!ipAddress) {
                return;
            }
            var deviceType = msg[10];
            if (deviceType !== 2) {
                // Must be PixelPusher device type
                return;
            }
            console.log("PixelPusher Device discovered at " + ipAddress + " [" + mac + "]");
            var deviceData = {
                macAddress: mac,
                ipAddress: ipAddress,
                deviceType: msg[10],
                protocolVrsn: msg[11],
                vendorID: msg.readUInt16LE(12),
                productID: msg.readUInt16LE(14),
                hardwareRev: msg.readUInt16LE(16),
                softwareRev: msg.readUInt16LE(18),
                linkSpeed: msg.readUInt32LE(20),
                numberStrips: msg[24],
                stripsPerPkt: msg[25],
                pixelsPerStrip: msg.readUInt16LE(26),
                updatePeriod: msg.readUInt32LE(28) / 1000,
                powerTotal: msg.readUInt32LE(32),
                deltaSequence: msg.readUInt32LE(36),
                controllerNo: msg.readInt32LE(40),
                groupNo: msg.readInt32LE(44),
                myPort: 9761
            };
            if (msg.length >= 54) {
                deviceData.artnetUniverse = msg.readUInt16LE(48);
                deviceData.artnetChannel = msg.readUInt16LE(50);
                deviceData.myPort = msg.readUInt16LE(52);
            }
            if (msg.length >= 62) {
                deviceData.stripFlags = msg
                    .slice(54, 62)
                    .toString('hex')
                    .match(/.{2}/g)
                    .map(function (x) {
                    return parseInt(x, 16);
                });
            }
            if (msg.length >= 66) {
                deviceData.pusherFlags = msg.readInt32LE(62);
            }
            var newDevice = new Device(deviceData);
            newDevice.sendPacket = function (packet, deviceData) {
                _this.socket.send(packet, 0, packet.length, deviceData.myPort, deviceData.ipAddress);
            };
            this.devices[mac] = newDevice;
            this.emit('discover', newDevice);
        };
        return Service;
    }(events.EventEmitter));

    exports.Service = Service;
    exports.Device = Device;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
