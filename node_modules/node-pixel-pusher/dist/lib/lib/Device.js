"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SEQUENCE_DENOTATION_LENGTH = 4;
var STRIP_DENOTATION_LENGTH = 1;
var NS_PER_SEC = 1e9;
var MS_PER_NS = 1e-6;
var Device = /** @class */ (function () {
    function Device(deviceData) {
        this.packetIndex = 0;
        this.packetSequenceNumber = 1;
        this.packetsPerRefresh = 1;
        this.minimumUpdatePeriod = 0;
        this.stripDataSize = 0;
        this.renderfn = function () { };
        this.shouldRender = false;
        this.deviceData = deviceData;
        this.packetBuffer = [];
        this.stripPacketData = [];
        this.stripDataSize = this.deviceData.pixelsPerStrip * 3;
        this.packetsPerRefresh = Math.ceil(this.deviceData.numberStrips / this.deviceData.stripsPerPkt);
        for (var p = 0; p < this.packetsPerRefresh; p++) {
            var stripOffset = this.deviceData.stripsPerPkt * p;
            var stripCount = Math.min(this.deviceData.stripsPerPkt, this.deviceData.numberStrips - stripOffset);
            var packetSize = SEQUENCE_DENOTATION_LENGTH + stripCount * (STRIP_DENOTATION_LENGTH + this.stripDataSize);
            var packet = (this.packetBuffer[p] = Buffer.alloc(packetSize));
            packet.fill(0x00);
            var pos = 4;
            var slen = stripOffset + stripCount;
            for (var s = stripOffset; s < slen; s++) {
                packet.writeUInt8(s, pos);
                // increment after writing UInt8
                pos += 1;
                this.stripPacketData.push({
                    packetIndex: p,
                    dataOffset: pos,
                    rgbaOffset: s * this.deviceData.pixelsPerStrip * 4
                });
                // increment to skip strip data
                pos += this.stripDataSize;
            }
        }
        this.fullRefreshTick = this.fullRefreshTick.bind(this);
    }
    Device.prototype.setRGBABuffer = function (data) {
        if (data.length !== this.deviceData.numberStrips * this.deviceData.pixelsPerStrip * 4) {
            console.log('Invalid buffer size');
            return;
        }
        for (var y = 0; y < this.deviceData.numberStrips; y++) {
            var meta = this.stripPacketData[y];
            var target = this.packetBuffer[meta.packetIndex];
            for (var i = 0, j = 0; i < this.stripDataSize; i += 3, j += 4) {
                target[meta.dataOffset + i] = data[meta.rgbaOffset + j];
                target[meta.dataOffset + i + 1] = data[meta.rgbaOffset + j + 1];
                target[meta.dataOffset + i + 2] = data[meta.rgbaOffset + j + 2];
            }
        }
    };
    Device.prototype.sendPacket = function (packet, deviceData) { };
    Device.prototype.fullRefreshTick = function () {
        var tickStartTime = process.hrtime();
        var sendPacket = true;
        if (!this.shouldRender) {
            // Stop render loop
            return;
        }
        if (this.packetIndex === 0) {
            // Request render data
            if (this.renderfn() === false) {
                sendPacket = false;
            }
        }
        if (sendPacket) {
            var packet = this.packetBuffer[this.packetIndex];
            packet.writeUInt32LE(this.packetSequenceNumber++, 0);
            this.sendPacket(packet, this.deviceData);
            this.packetIndex = (this.packetIndex + 1) % this.packetsPerRefresh;
        }
        var tickHRTime = process.hrtime(tickStartTime);
        var tickMS = (tickHRTime[0] * NS_PER_SEC + tickHRTime[1]) * MS_PER_NS;
        setTimeout(this.fullRefreshTick, Math.max(
        // Don't go below update limit
        this.minimumUpdatePeriod, 
        // Skip to next frame render if we're not sending packets
        (sendPacket
            ? this.deviceData.updatePeriod
            : this.deviceData.updatePeriod * this.packetsPerRefresh) -
            // Remove time used by render/packet sending
            tickMS));
    };
    Device.prototype.setMaxFPS = function (maxFps) {
        this.minimumUpdatePeriod = 1000 / maxFps / this.packetsPerRefresh;
    };
    Device.prototype.startRendering = function (renderfn, maxFps) {
        var shouldStartRender = !this.shouldRender;
        if (maxFps) {
            this.setMaxFPS(maxFps);
        }
        this.renderfn = renderfn;
        if (shouldStartRender) {
            this.shouldRender = true;
            this.fullRefreshTick();
        }
    };
    Device.prototype.stopRendering = function () {
        this.shouldRender = false;
    };
    return Device;
}());
exports.default = Device;
//# sourceMappingURL=Device.js.map